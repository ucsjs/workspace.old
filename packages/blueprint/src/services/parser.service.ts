import * as fs from "fs";
import * as path from "path";
import * as fg from "fast-glob";

export class Parser {
    private _namespace: string;
    private _metadata: any;
    private _resolve: any;
    private _cwd: string;

    constructor(namespace: string, metadata: any, resolve: any, cwd: string){
        this._namespace = namespace;
        this._metadata = metadata;
        this._resolve = resolve;
        this._cwd = cwd;
    }

    async export(){
        let scriptText = `// Auto-generated by Blueprint \n
import * as path from "path";
import { Subject } from 'rxjs';
import { Blueprint, Flow } from "@ucsjs/blueprint";\n`;

        let imports = []
        for(let item of this._metadata.items){
            if(!imports.includes(item.namespace) && item.namespace != "OutputBlueprint") {
                scriptText += `const { ${item.namespace} } = require(path.resolve("${await this.resolve(item.namespace)}"));\n`;
                imports.push(item.namespace);
            }
        }

        scriptText += `\nexport class ${this._namespace} extends Blueprint { \n`;

        if(this._metadata.items){
            scriptText += `\texec(){\n`;
            scriptText += `\t\tconst subject = new Subject<any>();\n\n`;
            scriptText += `\t\tnew Flow({\n`;

            for(let key in this._metadata.items){
                const newDefaults = {};
                let hasInputs = false;

                for(let keyPublicVars in this._metadata.items[key].publicVars){
                    if(this._metadata.items[key].publicVars[keyPublicVars].value){
                        newDefaults[this._metadata.items[key].publicVars[keyPublicVars].name] = this._metadata.items[key].publicVars[keyPublicVars].value;
                        hasInputs = true;
                    }                        
                }

                if(this._metadata.items[key].namespace != "OutputBlueprint")
                    scriptText += `\t\t\t${this._metadata.items[key].namespace.toLowerCase()}${key}: new ${this._metadata.items[key].namespace}(${(hasInputs) ? JSON.stringify(newDefaults) : ''}),\n`;
            }

            scriptText += `\t\t}, subject)\n`;
            
            if(this._metadata.connections){
                for(let connection of this._metadata.connections){
                    const input = this.getInput(connection.from.component, connection.from.input);
                    const output = this.getInput(connection.to.component, connection.to.input);

                    if(connection.to.component == "OutputBlueprint")
                        scriptText += `\t\t.output("${connection.from.component.toLowerCase()}${connection.from.input.split("-")[1]}", "${input}")\n`;
                    else if(input && output)
                        scriptText += `\t\t.subscribe("${connection.from.component.toLowerCase()}${connection.from.input.split("-")[1]}", "${input}", "${connection.to.component.toLowerCase()}${connection.to.input.split("-")[1]}", "${output}")\n`;                    
                }
            }

            scriptText += `\t\t.start();\n\n`;
            scriptText += `\t\treturn subject;\n`;
            scriptText += `\t}\n`;
        }

        scriptText += `}\n\n`;

        scriptText += `export default ${this._namespace};\n`;

        return scriptText;
    }

    getInput(component, inputId){
        for(let key in this._metadata.items){
            const item = this._metadata.items[key];
            if(item.namespace == component){
                for(let input of item.inputs){
                    if(`${input.id}-${key}` == inputId){
                        return input.name;
                    }
                }

                for(let input of item.outputs){
                    if(`${input.id}-${key}` == inputId){
                        return input.name;
                    }
                }
            }
        }
    }

    async resolve(namespace){
        for(let key in this._resolve)
            this._resolve[key] = path.resolve(this._resolve[key]);
        
        const files = await fg(this._resolve, { dot: true, onlyFiles: true });
        
        for(let file of files){
            const content = fs.readFileSync(file, "utf-8");
            
            if(content.indexOf(namespace) > -1){
                return file.replace(`${this._cwd}/`, "");
            }
        }
    }
}